export class Face3 {
    constructor(a: any, b: any, c: any, normal: any, color: any, materialIndex?: number);
    a: any;
    b: any;
    c: any;
    normal: any;
    vertexNormals: any[];
    color: any;
    vertexColors: any[];
    materialIndex: number;
    clone(): any;
    copy(source: any): this;
}
export class Geometry extends EventDispatcher<any> {
    static createBufferGeometryFromObject(object: any): BufferGeometry<import("three").NormalBufferAttributes>;
    constructor();
    uuid: string;
    name: string;
    type: string;
    vertices: any[];
    colors: any[];
    faces: any[];
    faceVertexUvs: never[][];
    morphTargets: any[];
    morphNormals: any[];
    skinWeights: any[];
    skinIndices: any[];
    lineDistances: any[];
    boundingBox: any;
    boundingSphere: any;
    elementsNeedUpdate: boolean;
    verticesNeedUpdate: boolean;
    uvsNeedUpdate: boolean;
    normalsNeedUpdate: boolean;
    colorsNeedUpdate: boolean;
    lineDistancesNeedUpdate: boolean;
    groupsNeedUpdate: boolean;
    applyMatrix4(matrix: any): this;
    rotateX(angle: any): this;
    rotateY(angle: any): this;
    rotateZ(angle: any): this;
    translate(x: any, y: any, z: any): this;
    scale(x: any, y: any, z: any): this;
    lookAt(vector: any): this;
    fromBufferGeometry(geometry: any): this;
    center(): this;
    normalize(): this;
    computeFaceNormals(): void;
    computeVertexNormals(areaWeighted?: boolean): void;
    computeFlatVertexNormals(): void;
    computeMorphNormals(): void;
    computeBoundingBox(): void;
    computeBoundingSphere(): void;
    merge(geometry: any, matrix: any, materialIndexOffset?: number): void;
    mergeMesh(mesh: any): void;
    mergeVertices(precisionPoints?: number): number;
    setFromPoints(points: any): this;
    sortFacesByMaterialIndex(): void;
    toJSON(): {
        metadata: {
            version: number;
            type: string;
            generator: string;
        };
    };
    clone(): Geometry;
    copy(source: any): this;
    toBufferGeometry(): BufferGeometry<import("three").NormalBufferAttributes>;
    computeTangents(): void;
    computeLineDistances(): void;
    applyMatrix(matrix: any): this;
    dispose(): void;
    isGeometry: boolean;
}
import { EventDispatcher } from 'three';
import { BufferGeometry } from 'three';
//# sourceMappingURL=geometry.d.ts.map