/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */
import { FileLoader, ImageLoader, ObjectLoader, TextureLoader } from 'three';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
export default class Loaders {
    constructor(cache, textureAnisotropy) {
        this.cache = cache;
        this.textureAnisotropy = textureAnisotropy;
    }
    get fileLoader() {
        if (!this._fileLoader)
            this._fileLoader = new FileLoader();
        return this._fileLoader;
    }
    get imageLoader() {
        if (!this._imgLoader)
            this._imgLoader = new ImageLoader();
        return this._imgLoader;
    }
    get svgLoader() {
        if (!this._svgLoader)
            this._svgLoader = new SVGLoader();
        return this._svgLoader;
    }
    get textureLoader() {
        if (!this._textureLoader)
            this._textureLoader = new TextureLoader();
        return this._textureLoader;
    }
    get objectLoader() {
        if (!this._objectLoader)
            this._objectLoader = new ObjectLoader();
        return this._objectLoader;
    }
    get gltfLoader() {
        if (!this._gltfLoader)
            this._gltfLoader = new GLTFLoader();
        return this._gltfLoader;
    }
    get fbxLoader() {
        if (!this._fbxLoader)
            this._fbxLoader = new FBXLoader();
        return this._fbxLoader;
    }
    async preload(key, url) {
        this.cache.add(key, url);
        return new Promise(resolve => {
            const isModel = /\.fbx$|\.glb$|\.gltf$/.test(url);
            const isTexture = /\.jpe?g$|\.png$/.test(url);
            if (isTexture) {
                this.textureLoader.load(url, texture => {
                    return resolve(texture);
                });
            }
            else {
                if (isModel)
                    this.fileLoader.setResponseType('arraybuffer');
                else
                    this.fileLoader.setResponseType('undefined');
                this.fileLoader.load(url, file => {
                    return resolve(file);
                });
            }
        });
    }
    async textureAtlas(texture, json, _type = 'JSONHash') {
        let parsed = JSON.parse((await this.file(json)));
        // convert JSONArray to JSONHash
        const isJSONArray = parsed.textures;
        if (isJSONArray) {
            const frames = parsed.textures[0].frames;
            let jsonHash = { frames: {} };
            frames.forEach(frame => {
                jsonHash = {
                    ...jsonHash,
                    frames: {
                        ...jsonHash.frames,
                        [frame.filename]: {
                            frame: frame.frame,
                            rotated: frame.rotated,
                            sourceSize: frame.sourceSize,
                            spriteSourceSize: frame.spriteSourceSize,
                            trimmed: frame.trimmed
                        }
                    }
                };
            });
            parsed = jsonHash;
        }
        const atlas = {
            texture: await this.texture(texture),
            json: parsed
        };
        return atlas;
    }
    file(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.fileLoader.load(url, file => {
                return resolve(file);
            });
        });
    }
    svg(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.svgLoader.load(url, svg => {
                return resolve(svg);
            });
        });
    }
    texture(url) {
        const isBase64 = /^data:image\/[\S]+;base64,/gm.test(url);
        // we do not want to cache base64 images
        if (!isBase64) {
            const key = this.cache.get(url);
            url = key ? key : url;
        }
        return new Promise(resolve => {
            this.textureLoader.load(url, (texture) => {
                texture.anisotropy = this.textureAnisotropy;
                texture.needsUpdate = true;
                resolve(texture);
            });
        });
    }
    // examples: https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4
    object(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.objectLoader.load(url, (json) => {
                resolve(json);
            });
        });
    }
    gltf(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.gltfLoader.load(url, (gltf) => {
                resolve(gltf);
            });
        });
    }
    fbx(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.fbxLoader.load(url, (fbx) => {
                resolve(fbx);
            });
        });
    }
}
//# sourceMappingURL=loaders.js.map